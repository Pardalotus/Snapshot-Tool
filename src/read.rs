use std::path::PathBuf;

use flate2::read::GzDecoder;
use tar::Archive;

use std::{
    fs::File,
    io::{self, BufRead, BufReader, Read},
    sync::mpsc::SyncSender,
};

use serde_json::Value;

/// Read all entries in all files to the channel. One entry per message.
pub(crate) fn read_paths_to_channel(
    paths: &[PathBuf],
    tx: SyncSender<Value>,
    verbose: bool,
) -> anyhow::Result<()> {
    for path in paths.iter() {
        // path::ends_with comparison for path doesn't work for sub-path-component chunks.
        // path::extension only takes the lats extension files so is unsuitbale for `.tar.gz`.
        if let Some(path_str) = path.to_str() {
            // Ignore other types.
            if path_str.ends_with(".tgz") {
                read_tgz_to_channel(path, &tx, verbose)?;
            } else if path_str.ends_with(".json.gz") {
                read_json_gz_to_channel(path, &tx, verbose)?;
            } else if path_str.ends_with(".jsonl.gz") {
                read_jsonl_gz_to_channel(path, &tx, verbose)?;
            }
        }
    }

    Ok(())
}

/// Read gzipped jsonl (JSON Lines) from a file to a channel, one string per line.
/// This format is generated by this tool.
fn read_jsonl_gz_to_channel(
    path: &PathBuf,
    channel: &SyncSender<Value>,
    verbose: bool,
) -> anyhow::Result<()> {
    let f = File::open(path)?;

    let decoded = BufReader::new(GzDecoder::new(f));

    let mut count: usize = 0;

    for line in decoded.lines() {
        let parsed: Value = serde_json::from_str(&line?)?;

        channel.send(parsed)?;
        count += 1;
        if verbose && count % 10000 == 0 {
            eprintln!("Read {} lines", count);
        }
    }

    Ok(())
}

/// Read a gzipped JSON file.
/// This is expected to be a Crossref file.
fn read_json_gz_to_channel(
    path: &PathBuf,
    tx: &SyncSender<Value>,
    verbose: bool,
) -> anyhow::Result<()> {
    if verbose {
        eprintln!("Reading .json.gz {:?}", &path);
    }

    let f = File::open(path)?;

    let json = BufReader::new(GzDecoder::new(f));
    let deserialized: Value = serde_json::from_reader(json)?;

    // Crossref files have a top-level key "items" containing items in that snapshot.
    if let Some(items) = deserialized.get("items").and_then(|x| x.as_array()) {
        let mut count: usize = 0;
        for item in items {
            // We're splitting the document into parts, so need to make a copy of this subtree.
            tx.send(item.clone())?;

            count += 1;
            if verbose && count % 10000 == 0 {
                eprintln!("From {:?} read {} lines", path, count);
            }
        }
    } else {
        eprint!("Didn't get recognised JSON format from {:?}", path);
    }

    if verbose {
        eprintln!("Finished reading .json.gz {:?}", &path);
    }

    Ok(())
}

/// Read all entries in all files in a gzipped tar file to a channel.
fn read_tgz_to_channel(
    path: &PathBuf,
    channel: &SyncSender<Value>,
    verbose: bool,
) -> anyhow::Result<()> {
    let tar_gz = File::open(path)?;
    let tar = BufReader::new(GzDecoder::new(tar_gz));

    let mut archive = Archive::new(tar);

    if verbose {
        eprintln!("Read TGZ {:?}", path);
    }

    for entry in archive.entries()? {
        let mut ok_entry = entry?;
        let entry_path = ok_entry.path()?;

        if entry_path
            .file_name()
            .and_then(|x| x.to_str())
            .map(|x| x.ends_with(".jsonl"))
            .unwrap_or(false)
        {
            if verbose {
                eprintln!("From TGZ {:?} read {:?}", path, entry_path);
            }

            read_jsonl_to_channel(&mut ok_entry, channel, verbose)?;
        }
    }

    if verbose {
        eprintln!("Finished reading TGZ {:?}", path);
    }

    Ok(())
}

/// Read a jsonl (JSON Lines) reader to a channel, one string per line.
/// These are expected to be found in DataCite snapshots.
fn read_jsonl_to_channel(
    reader: &mut dyn Read,
    channel: &SyncSender<Value>,
    verbose: bool,
) -> anyhow::Result<()> {
    let reader = io::BufReader::new(reader);

    let mut count: usize = 0;

    for line in reader.lines() {
        let parsed: Value = serde_json::from_str(&line?)?;

        channel.send(parsed)?;
        count += 1;
        if verbose && count % 10000 == 0 {
            eprintln!("Read {} lines", count);
        }
    }

    Ok(())
}
